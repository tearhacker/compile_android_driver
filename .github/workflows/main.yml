name: Android Kernel Driver Builder

on:
  workflow_dispatch:
    inputs:
      android_version:
        description: 'Android Version (e.g., 13, 14, 15)'
        required: true
        default: '14'
      kernel_version:
        description: 'Kernel Version (e.g., 5.15, 6.1, 6.6)'
        required: true
        default: '6.1'
      driver_name:
        description: 'Driver Module Name (e.g., hello.ko)'
        required: true
        default: 'hello.ko'
      target_arch:
        description: 'Target Architecture'
        required: true
        default: 'aarch64'

env:
  ANDROID_VERSION: ${{ github.event.inputs.android_version }}
  KERNEL_VERSION: ${{ github.event.inputs.kernel_version }}
  DRIVER_NAME: ${{ github.event.inputs.driver_name }}
  TARGET_ARCH: ${{ github.event.inputs.target_arch }}

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free up disk space
        run: |
          echo "=== 清理磁盘空间 ==="
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL /opt/hostedtoolcache/go /opt/hostedtoolcache/node
          sudo docker image prune --all --force || true
          df -h

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential flex bison libssl-dev libelf-dev bc \
            python-is-python3 git-lfs cpio kmod

      - name: Install repo tool
        run: |
          sudo curl -L https://storage.googleapis.com/git-repo-downloads/repo -o /usr/local/bin/repo
          sudo chmod a+x /usr/local/bin/repo

      - name: Sync Android Kernel source
        run: |
          mkdir -p android-kernel && cd android-kernel
          repo init -u https://android.googlesource.com/kernel/manifest \
            -b common-android${ANDROID_VERSION}-${KERNEL_VERSION}
          repo sync -j$(nproc) -c --no-tags --optimized-fetch --force-sync

      - name: Prepare driver source
        run: |
          mkdir -p android-kernel/external_modules/hello
          cp ./helloWorld/Hello.c android-kernel/external_modules/hello/
          
          # 创建独立模块 Makefile (obj-m 编译为 .ko)
          echo 'obj-m += hello.o' > android-kernel/external_modules/hello/Makefile
          echo 'hello-objs := Hello.o' >> android-kernel/external_modules/hello/Makefile
          
          echo "=== Makefile 内容 ==="
          cat android-kernel/external_modules/hello/Makefile
          ls -la android-kernel/external_modules/hello/

      - name: Build Kernel (Android 13 and below - build.sh)
        if: ${{ github.event.inputs.android_version == '12' || github.event.inputs.android_version == '13' }}
        run: |
          cd android-kernel
          
          # 添加 kprobe 符号到白名单
          for symbol in register_kprobe unregister_kprobe; do
            grep -q "$symbol" common/android/abi_gki_${TARGET_ARCH} || \
            echo "  $symbol" >> common/android/abi_gki_${TARGET_ARCH}
          done
          
          # 编译内核
          BUILD_CONFIG=common/build.config.gki.${TARGET_ARCH} \
            LTO=thin \
            SKIP_ABI_CHECKS=1 \
            build/build.sh -j$(nproc)
          
          # 设置输出路径
          echo "KERNEL_OUT=$(pwd)/out/android${ANDROID_VERSION}-${KERNEL_VERSION}/dist" >> $GITHUB_ENV

      - name: Build Kernel (Android 14+ - Bazel)
        if: ${{ github.event.inputs.android_version != '12' && github.event.inputs.android_version != '13' }}
        run: |
          cd android-kernel
          
          echo "=== 使用 Bazel 构建 Android ${ANDROID_VERSION} 内核 ==="
          
          # 构建内核和模块开发所需文件
          # 使用 kernel_aarch64_dist 目标，包含完整的模块开发文件
          tools/bazel run //common:kernel_${TARGET_ARCH}_dist -- --dist_dir=dist
          
          echo "=== 构建产物 ==="
          ls -la dist/ || true
          
          # 检查关键文件
          echo "=== 检查 Module.symvers ==="
          if [ -f "dist/Module.symvers" ]; then
            echo "Module.symvers 存在，行数: $(wc -l < dist/Module.symvers)"
            head -20 dist/Module.symvers
          else
            echo "::warning::dist/Module.symvers 不存在"
            find . -name "Module.symvers" 2>/dev/null | head -5
          fi
          
          echo "=== 检查 .config ==="
          if [ -f "dist/.config" ]; then
            echo ".config 存在"
            grep -E "^CONFIG_(MODULES|KASAN)" dist/.config | head -10
          fi
          
          echo "KERNEL_OUT=$(pwd)/dist" >> $GITHUB_ENV

      - name: Build external module
        run: |
          cd android-kernel
          
          echo "=== 编译外部模块 ==="
          
          # 安装 LLVM 工具链和交叉编译器
          sudo apt-get install -y clang lld llvm gcc-aarch64-linux-gnu
          
          # 查找预置的交叉编译工具链
          CLANG_BIN=$(find prebuilts -path "*/linux-x86/clang-*/bin" -type d 2>/dev/null | head -1)
          GCC_BIN=$(find prebuilts -path "*aarch64*linux-android*/bin" -type d 2>/dev/null | head -1)
          
          # 优先使用预置工具链，否则用系统的
          if [ -n "$CLANG_BIN" ] && [ -f "$CLANG_BIN/clang" ]; then
            echo "使用预置 clang: $CLANG_BIN"
          else
            CLANG_BIN="/usr/bin"
            echo "使用系统 clang: $CLANG_BIN"
          fi
          
          echo "CLANG_BIN: $CLANG_BIN"
          echo "GCC_BIN: $GCC_BIN"
          
          # 确保 ld.lld 可用
          which ld.lld || sudo ln -sf /usr/bin/lld /usr/bin/ld.lld
          
          export PATH="$CLANG_BIN:$GCC_BIN:/usr/bin:$PATH"
          
          # 验证工具链
          echo "=== 工具链版本 ==="
          clang --version | head -1
          ld.lld --version | head -1
          
          # 准备内核源码目录
          KERNEL_SRC="$(pwd)/common"
          MODULE_DIR="$(pwd)/external_modules/hello"
          
          # ========== 方案1: 使用 dist 目录的构建产物 ==========
          echo "=== 查找 Bazel 构建产物 ==="
          
          # 列出所有可能的位置
          echo "--- 搜索 Module.symvers ---"
          find . -name "Module.symvers" -type f 2>/dev/null
          echo "--- 搜索 .config ---"
          find . -name ".config" -type f 2>/dev/null | grep -v ".config.old" | head -10
          
          # 优先使用 dist 目录
          SYMVERS_FILE=""
          CONFIG_FILE=""
          
          if [ -f "dist/Module.symvers" ]; then
            SYMVERS_FILE="dist/Module.symvers"
          fi
          if [ -f "dist/.config" ]; then
            CONFIG_FILE="dist/.config"
          fi
          
          # 如果 dist 没有，搜索 bazel-out
          if [ -z "$SYMVERS_FILE" ]; then
            SYMVERS_FILE=$(find bazel-out -name "Module.symvers" 2>/dev/null | head -1)
          fi
          if [ -z "$CONFIG_FILE" ]; then
            CONFIG_FILE=$(find bazel-out -name ".config" 2>/dev/null | grep -v ".config.old" | head -1)
          fi
          
          echo "找到 Module.symvers: $SYMVERS_FILE"
          echo "找到 .config: $CONFIG_FILE"
          
          # 复制关键文件到源码目录
          if [ -n "$SYMVERS_FILE" ] && [ -f "$SYMVERS_FILE" ]; then
            echo "=== 复制 Module.symvers ==="
            cp "$SYMVERS_FILE" "$KERNEL_SRC/"
            echo "Module.symvers 行数: $(wc -l < $KERNEL_SRC/Module.symvers)"
          fi
          
          if [ -n "$CONFIG_FILE" ] && [ -f "$CONFIG_FILE" ]; then
            echo "=== 复制 .config ==="
            cp "$CONFIG_FILE" "$KERNEL_SRC/"
          fi
          
          # 复制生成的头文件 (从 dist 或 bazel-out)
          for search_dir in dist bazel-out; do
            if [ -d "$search_dir" ]; then
              # 查找 include/generated 和 include/config
              GEN_DIR=$(find "$search_dir" -path "*/include/generated" -type d 2>/dev/null | head -1)
              CFG_DIR=$(find "$search_dir" -path "*/include/config" -type d 2>/dev/null | head -1)
              
              if [ -n "$GEN_DIR" ]; then
                echo "复制 generated headers from $GEN_DIR"
                mkdir -p "$KERNEL_SRC/include/generated"
                cp -r "$GEN_DIR"/* "$KERNEL_SRC/include/generated/" 2>/dev/null || true
              fi
              if [ -n "$CFG_DIR" ]; then
                echo "复制 config headers from $CFG_DIR"
                mkdir -p "$KERNEL_SRC/include/config"
                cp -r "$CFG_DIR"/* "$KERNEL_SRC/include/config/" 2>/dev/null || true
              fi
            fi
          done
          
          # 如果还是没有 .config，生成默认配置
          if [ ! -f "$KERNEL_SRC/.config" ]; then
            echo "=== 生成默认 GKI 配置 ==="
            make -C "$KERNEL_SRC" ARCH=arm64 LLVM=1 gki_defconfig
          fi
          
          # 关键修复：禁用 KASAN 避免 __asan_* 符号问题
          echo "=== 调整内核配置 (禁用 KASAN/KCSAN 等调试选项) ==="
          CONFIG_DISABLE_LIST="
            CONFIG_KASAN
            CONFIG_KASAN_GENERIC
            CONFIG_KASAN_SW_TAGS
            CONFIG_KASAN_HW_TAGS
            CONFIG_KASAN_INLINE
            CONFIG_KASAN_OUTLINE
            CONFIG_KCSAN
            CONFIG_UBSAN
            CONFIG_CFI_CLANG
          "
          for cfg in $CONFIG_DISABLE_LIST; do
            sed -i "s/${cfg}=y/# ${cfg} is not set/" "$KERNEL_SRC/.config" 2>/dev/null || true
          done
          
          # 确保模块支持开启
          grep -q "CONFIG_MODULES=y" "$KERNEL_SRC/.config" || echo "CONFIG_MODULES=y" >> "$KERNEL_SRC/.config"
          grep -q "CONFIG_MODULE_UNLOAD=y" "$KERNEL_SRC/.config" || echo "CONFIG_MODULE_UNLOAD=y" >> "$KERNEL_SRC/.config"
          
          # 准备内核构建环境
          echo "=== 准备内核构建环境 ==="
          make -C "$KERNEL_SRC" ARCH=arm64 \
            CC=clang LD=ld.lld LLVM=1 \
            CROSS_COMPILE=aarch64-linux-gnu- \
            olddefconfig
          
          make -C "$KERNEL_SRC" ARCH=arm64 \
            CC=clang LD=ld.lld LLVM=1 \
            CROSS_COMPILE=aarch64-linux-gnu- \
            modules_prepare
          
          # 验证 Module.symvers 存在
          if [ ! -f "$KERNEL_SRC/Module.symvers" ] || [ ! -s "$KERNEL_SRC/Module.symvers" ]; then
            echo "::warning::Module.symvers 缺失或为空"
            # 尝试从 vmlinux 提取符号 (备选方案)
            VMLINUX=$(find dist bazel-out -name "vmlinux" -type f 2>/dev/null | head -1)
            if [ -n "$VMLINUX" ]; then
              echo "尝试从 vmlinux 生成 Module.symvers..."
              nm "$VMLINUX" 2>/dev/null | grep -E " (T|D|R) " | awk '{print "0x00000000\t"$3"\tvmlinux\tEXPORT_SYMBOL"}' > "$KERNEL_SRC/Module.symvers" || true
            fi
          fi
          
          # 编译外部模块
          echo "=== 编译外部模块 ==="
          make -C "$KERNEL_SRC" M="$MODULE_DIR" \
            ARCH=arm64 \
            CC=clang LD=ld.lld LLVM=1 \
            CROSS_COMPILE=aarch64-linux-gnu- \
            KBUILD_MODPOST_WARN=1 \
            modules V=1 2>&1 | tee /tmp/module_build.log || true
          
          # 检查是否生成了 .ko 文件
          KO_FILE=$(find "$MODULE_DIR" -name "*.ko" -type f 2>/dev/null | head -1)
          
          if [ -z "$KO_FILE" ]; then
            echo "=== 方案1失败，尝试方案2: 使用 Bazel 编译外部模块 ==="
            
            # 创建 Bazel BUILD 文件
            cat > external_modules/hello/BUILD.bazel << 'EOF'
          load("//build/kernel/kleaf:kernel.bzl", "kernel_module")

          kernel_module(
              name = "hello",
              srcs = ["Hello.c", "Makefile"],
              outs = ["hello.ko"],
              kernel_build = "//common:kernel_aarch64",
          )
          EOF
            
            # 尝试 Bazel 编译
            tools/bazel build //external_modules/hello:hello 2>&1 || {
              echo "Bazel 编译也失败，查看错误日志..."
              cat /tmp/module_build.log | tail -50
              
              # 最后尝试：直接用简化的编译命令
              echo "=== 方案3: 简化编译 ==="
              cd "$MODULE_DIR"
              
              # 直接编译 .o 文件
              clang --target=aarch64-linux-gnu \
                -I"$KERNEL_SRC/include" \
                -I"$KERNEL_SRC/arch/arm64/include" \
                -I"$KERNEL_SRC/arch/arm64/include/generated" \
                -I"$KERNEL_SRC/include/generated" \
                -D__KERNEL__ -DMODULE -DKBUILD_MODNAME='"hello"' \
                -fno-pic -fno-stack-protector \
                -c Hello.c -o hello.o 2>&1 || true
              
              cd -
            }
            
            # 再次查找 .ko
            KO_FILE=$(find . -name "hello.ko" -type f 2>/dev/null | head -1)
          fi
          
          echo "=== 查找编译产物 ==="
          find . -name "*.ko" -type f 2>/dev/null
          
          # 复制 .ko 到输出目录
          mkdir -p $GITHUB_WORKSPACE/output
          find . -name "*.ko" -exec cp {} $GITHUB_WORKSPACE/output/ \; 2>/dev/null || true
          
          # 检查是否成功
          if ls $GITHUB_WORKSPACE/output/*.ko 1>/dev/null 2>&1; then
            echo "=== 模块编译成功 ==="
            for ko in $GITHUB_WORKSPACE/output/*.ko; do
              echo "--- $ko ---"
              file "$ko"
              
              echo "--- 模块依赖的符号 ---"
              ${CLANG_BIN}/llvm-nm "$ko" 2>/dev/null | grep " U " | head -20 || nm "$ko" | grep " U " | head -20 || true
              
              echo "--- vermagic ---"
              strings "$ko" | grep vermagic || true
            done
          else
            echo "::error::所有编译方案都失败了"
            echo "=== 编译日志 ==="
            cat /tmp/module_build.log | tail -100
            exit 1
          fi

      - name: Collect build artifacts
        run: |
          cd android-kernel
          
          echo "=== 收集编译产物 ==="
          mkdir -p $GITHUB_WORKSPACE/output/kernel
          
          # 复制内核镜像
          for file in Image Image.lz4 Image.gz vmlinux System.map .config Module.symvers; do
            find . -name "$file" -type f -exec cp {} $GITHUB_WORKSPACE/output/kernel/ \; 2>/dev/null || true
          done
          
          ls -la $GITHUB_WORKSPACE/output/
          ls -la $GITHUB_WORKSPACE/output/kernel/

      - name: Package kernel source
        run: |
          cd android-kernel
          
          echo "=== 清理不必要文件 ==="
          find . -name ".git" -type d -exec rm -rf {} + 2>/dev/null || true
          find . -name "*.o" -delete 2>/dev/null || true
          find . -name "*.cmd" -delete 2>/dev/null || true
          
          echo "=== 打包内核源码 ==="
          ARCHIVE_NAME="kernel-source-android${ANDROID_VERSION}-${KERNEL_VERSION}-${TARGET_ARCH}"
          
          # 只打包 common 目录（主要源码）
          tar -cvf - common | gzip -1 > $GITHUB_WORKSPACE/output/${ARCHIVE_NAME}.tar.gz
          
          # 检查大小，如果超过 2GB 则分卷
          SIZE=$(stat -c%s "$GITHUB_WORKSPACE/output/${ARCHIVE_NAME}.tar.gz")
          if [ $SIZE -gt 2000000000 ]; then
            echo "文件过大，进行分卷..."
            rm $GITHUB_WORKSPACE/output/${ARCHIVE_NAME}.tar.gz
            tar -cvf - common | split -b 1900M - $GITHUB_WORKSPACE/output/${ARCHIVE_NAME}.tar.part
          fi
          
          ls -lh $GITHUB_WORKSPACE/output/

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.ANDROID_VERSION }}-${{ env.KERNEL_VERSION }}-${{ github.run_number }}
          name: "GKI Kernel Android${{ env.ANDROID_VERSION }}-${{ env.KERNEL_VERSION }} (${{ env.TARGET_ARCH }})"
          body: |
            ## GKI 内核编译产物
            
            | 项目 | 值 |
            |------|-----|
            | Android 版本 | ${{ env.ANDROID_VERSION }} |
            | 内核版本 | ${{ env.KERNEL_VERSION }} |
            | 架构 | ${{ env.TARGET_ARCH }} |
            | 驱动模块 | ${{ env.DRIVER_NAME }} |
            
            ### 包含文件
            - `hello.ko` - 编译好的内核模块
            - `kernel/` - 内核镜像 (Image, vmlinux, Module.symvers 等)
            - `kernel-source-*.tar.gz` - 完整内核源码
            
            ### 加载模块
            ```bash
            # 推送到设备
            adb push hello.ko /data/local/tmp/
            
            # 加载模块 (需要 root)
            adb shell su -c "insmod /data/local/tmp/hello.ko"
            
            # 查看日志
            adb shell dmesg | grep -i hello
            
            # 卸载模块
            adb shell su -c "rmmod hello"
            ```
            
            ### 使用源码编译其他模块
            ```bash
            # 解压源码
            tar -xzf kernel-source-*.tar.gz
            
            # 编译你的模块
            make -C common M=/path/to/your/module \
              ARCH=arm64 \
              CROSS_COMPILE=aarch64-linux-gnu- \
              LLVM=1 \
              modules
            ```
          files: |
            output/*.ko
            output/kernel/*
            output/*.tar.gz
            output/*.tar.part*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
